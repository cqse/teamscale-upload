import org.apache.tools.ant.taskdefs.condition.Os
import org.gradle.api.tasks.testing.logging.TestExceptionFormat

plugins {
	id 'org.beryx.runtime'
	id 'java'
}

repositories {
	maven {
		url "https://packages.jetbrains.team/maven/p/ij/intellij-dependencies/"
	}
	mavenCentral()
}

group = "com.teamscale"
version = "1.0-SNAPSHOT"

application {
	applicationName = 'teamscale-upload'

	mainClass = 'com.teamscale.upload.TeamscaleUpload'

	applicationDefaultJvmArgs = [
			// Ensure that no stack traces are lost.
			// See <https://stackoverflow.com/questions/2411487/nullpointerexception-in-java-with-no-stacktrace>
			'-XX:-OmitStackTraceInFastThrow',
	]
}

java {
	toolchain {
		// Ensure that we build with the same version that we want to jlink to the distribution.
		// Before making this explicit, I got this error in the build: "Error: Error reading module: /home/runner/work/teamscale-upload/teamscale-upload/build/jdks/linux-x86_64/jdk-17.0.5+8/jmods/java.security.sasl.jmod"
		// I think the build was using Java 11 then.
		languageVersion = JavaLanguageVersion.of(17)
		// I would like to also use the same vendor as in jlink, but gradle can't find/download a toolchain for this vendor
		//vendor = JvmVendorSpec.ADOPTIUM
	}
}

dependencies {
	implementation group: 'org.apache.commons', name: 'commons-exec', version: '1.3'
	implementation group: 'commons-io', name: 'commons-io', version: '2.11.0'
	implementation group: 'org.apache.commons', name: 'commons-compress', version: '1.21'
	implementation group: 'org.apache.commons', name: 'commons-lang3', version: '3.12.0'
	implementation group: 'com.google.code.gson', name: 'gson', version: '2.8.9'
	implementation group: 'com.google.guava', name: 'guava', version: '32.1.2-jre'
	implementation group: 'com.squareup.okhttp3', name: 'okhttp', version: '5.1.0'
	implementation group: 'net.sourceforge.argparse4j', name: 'argparse4j', version: '0.9.0'
	implementation group: 'org.jetbrains.nativecerts', name: 'jvm-native-trusted-roots', version: '1.0.19'

	testImplementation group: 'com.sparkjava', name: 'spark-core', version: '2.9.4'

	testImplementation platform("org.junit:junit-bom:5.10.2")
	testImplementation 'org.junit.jupiter:junit-jupiter-api'
	testImplementation 'org.junit.jupiter:junit-jupiter-params'
	testRuntimeOnly  'org.junit.jupiter:junit-jupiter-engine'

	testImplementation group: 'org.assertj', name: 'assertj-core', version: '3.21.0'
	testRuntimeOnly group: 'javax.servlet', name: 'javax.servlet-api', version: '4.0.1'

	testRuntimeOnly("org.junit.platform:junit-platform-launcher")
}
/* A provider that lazily executes 'git describe' and calculates the version.
 * This is Configuration Cache SAFE.
 */
def gitVersionProvider = providers.exec {
	// Run 'git describe --tags'. This handles both exact tags and dev commits.
	commandLine 'git', 'describe', '--tags'
	// Ignore the exit value so the build doesn't fail if there are no tags.
	ignoreExitValue true
	// We'll process the output (including errors) in the .map() block below.
}.standardOutput.asText.map { output ->
	def fullVersion = output.trim()
	if (fullVersion.isEmpty()) {
		// If git describe fails (e.g., no repo, no tags), use a default.
		return "0.1.0-SNAPSHOT"
	}
	if (fullVersion.contains('-')) {
		// It's a development commit, e.g., "v1.2.0-5-gabc123d".
		// We want to turn this into "1.2.0-SNAPSHOT".
		def baseVersion = fullVersion.split('-')[0]
		baseVersion = baseVersion.startsWith('v') ? baseVersion.substring(1) : baseVersion
		return "${baseVersion}-SNAPSHOT"
	} else {
		// It's an exact tag match, e.g., "v1.2.0". This is a release.
		return fullVersion.startsWith('v') ? fullVersion.substring(1) : fullVersion
	}
}
// === Set the project version using the provider ===
version = gitVersionProvider
// === Task to generate the Version.java source file ===
def generatedSourcesDir = layout.buildDirectory.dir('generated/sources/java')

tasks.register('generateVersionSource', Copy) {
	description = 'Generates the Version.java class from its template.'
	group = 'Source Generation'

	from('src/main/templates/java')
	// The template file is our input
	include('**/ToolVersion.java')
    // The generated sources directory is our output
	into(generatedSourcesDir)

	// Replace the ${ToolVersion} token with the actual project version
	// Instead of passing all properties, we pass a map where the
	// all values are provider. This triggers Gradle's lazy, provider-aware
	// expansion logic. Otherwise it would just call provider.toString() and
	// write "map(map(map(valueof(ProcessOutputValueSource))))" as version number.
	expand([ 'ToolVersion': project.version.get() ])
}

// Add the generated sources directory to the 'main' source set.
// This tells the 'compileJava' task to include the generated file.
// It also automatically makes 'compileJava' depend on 'generateVersionSource'.
sourceSets {
	main {
		java {
			srcDir generatedSourcesDir
		}
	}
}
tasks.named('compileJava') {
	dependsOn(tasks.named('generateVersionSource'))
}
tasks.named('build') {
	dependsOn(tasks.named('generateVersionSource'))
}
tasks.named('distTar') {
	archiveVersion.set(gitVersionProvider)
}
tasks.named('distZip') {
	archiveVersion.set(gitVersionProvider)
}

tasks.named('jar') {
	// Explicitly set the archiveVersion using our provider. This is the correct lazy configuration.

	// If we don't set this, then the "jar" task will implicitly use project.version (which is not a string but a provider) and append it to the application name.
	// Result would be a "teamscale-upload-map(map(map(valueof(ProcessOutputValueSource)))).jar".
	archiveVersion.set(gitVersionProvider)
}

def RUNTIME_JDK_VERSION = '17.0.5+8'
runtime {
	options = [
			'--compress', '2', // ZIP compression
			'--no-header-files', '--no-man-pages',
			'--dedup-legal-notices', 'error-if-not-same-content',
			'--strip-debug',
	]

	modules = [
			'java.logging', // For package java.util.logging (used by Google Guava)
			'java.naming', // For package javax.naming (used by Apache HttpClient)
			'jdk.crypto.ec', // For Elliptic Curve algorithms over TLS
			'jdk.unsupported', // For GSON
	]

	def ADOPTIUM_BINARY_REPOSITORY = 'https://api.adoptium.net/v3/binary'

	// We need to download the JDK, not the JRE, as the latter doesn't ship the jmod files needed by jlink
	targetPlatform('linux-x86_64') {
		jdkHome = jdkDownload("$ADOPTIUM_BINARY_REPOSITORY/version/jdk-${RUNTIME_JDK_VERSION}/linux/x64/jdk/hotspot/normal/eclipse") {
			archiveExtension = 'tar.gz'
		}
	}
	targetPlatform('windows-x86_64') {
		jdkHome = jdkDownload("$ADOPTIUM_BINARY_REPOSITORY/version/jdk-${RUNTIME_JDK_VERSION}/windows/x64/jdk/hotspot/normal/eclipse") {
			archiveExtension = 'zip'
		}
	}
	targetPlatform('macos-x86_64') {
		jdkHome = jdkDownload("$ADOPTIUM_BINARY_REPOSITORY/version/jdk-${RUNTIME_JDK_VERSION}/mac/x64/jdk/hotspot/normal/eclipse") {
			archiveExtension = 'tar.gz'
		}
	}
	targetPlatform('macos-aarch64') {
		jdkHome = jdkDownload("$ADOPTIUM_BINARY_REPOSITORY/version/jdk-${RUNTIME_JDK_VERSION}/mac/aarch64/jdk/hotspot/normal/eclipse") {
			archiveExtension = 'tar.gz'
		}
	}
	imageDir.set(layout.buildDirectory.dir("runtime/install"))
	imageZip.set(layout.buildDirectory.file("runtime/zip/${application.applicationName}.zip"))
}

// Use afterEvaluate to defer this logic until the configuration phase is complete.
// This guarantees that 'extensions.runtime.targetPlatforms' is populated.
project.afterEvaluate {
	// We still need to .get() here, but it's now safe inside afterEvaluate.
	extensions.runtime.targetPlatforms.get().each { targetPlatform ->
		tasks.register("customRuntimeZip-${targetPlatform.key}", Zip) {
			group = 'Build'
			description = "Builds a custom runtime zip for ${targetPlatform.key}"

			dependsOn tasks.named('runtime')
			dependsOn(tasks.named('generateVersionSource'))

			// The doFirst check is an execution-time action, so it's perfectly fine.
			doFirst {
				// It's better to check the target, not the build host, for this logic.
				// If building a linux zip on Windows is the issue, this check is correct.
				if (Os.isFamily(Os.FAMILY_WINDOWS) && !targetPlatform.key.contains('windows')) {
					throw new GradleException("Can't build non-Windows distributions on a Windows host due to lost file permissions. Target was: ${targetPlatform.key}.")
				}
			}

			// --- LAZY PROPERTY ASSIGNMENTS ---
			// Use .set() for modern lazy properties instead of direct assignment (=).
			destinationDirectory.set(layout.buildDirectory.dir('distributions'))
			// Use a provider for the applicationName to ensure it's also lazy.
			archiveFileName.set("${application.applicationName}-${targetPlatform.key}.zip")

			// --- LAZY FILE SELECTION ---
			// The content of the zip is configured lazily.
			from(runtime.imageDir.dir("${project.name}-${targetPlatform.key}")) {
				into(application.applicationName) // applicationName is a Provider
			}

			// Select the README lazily based on the targetPlatform, not the build OS.
			// This makes the build more reliable and portable.
			from(project.provider {
				if (targetPlatform.key.contains('windows')) {
					return "distribution_readme/README_WINDOWS.md"
				} else {
					return "distribution_readme/README_UNIX.md"
				}
			}) {
				rename { "README.md" }
				into(application.applicationName)
			}
			from(project.provider {
				"build/version.txt"
			}) {
				rename { "version.txt" }
				into(application.applicationName)
			}
		}
	}
}

test {
	useJUnitPlatform()
	filter {
		// Don't run the integration test for the graal-vm distribution artifact here. (This is the jlink build.)
		excludeTestsMatching('com.teamscale.upload.NativeImageIT')
	}
	testLogging {
		outputs.upToDateWhen { false }
		showStandardStreams = true
		showExceptions = true
		showCauses = true
		exceptionFormat = TestExceptionFormat.FULL
	}
}
tasks.register('printVersion') {
	description = 'Prints the current project version to the console.'
	group = 'Versioning' // Puts it in a nice group in `gradle tasks`

	// This block runs during the Execution Phase
	doLast {
		// Gradle automatically unwraps the version Provider when accessed here
		println "Project version: ${project.version.get()}"
	}
}
